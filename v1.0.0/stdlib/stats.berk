//! # Stats Module
//!
//! Statistics and probability (descriptive, inferential).
//!
//! İstatistik ve olasılık (tanımlayıcı, çıkarsamalı).
//!
//! ## Features / Özellikler
//!
//! - **Descriptive**: Mean, median, mode, variance / Tanımlayıcı
//! - **Quantiles**: Percentiles / Yüzdelikler
//! - **Correlation**: Covariance / Korelasyon
//! - **Moments**: Skewness, kurtosis / Çarpıklık, bassaklık
//! - **Hypothesis tests**: t-test, chi-square, ANOVA / Hipotez testleri
//! - **Distributions**: PDF, CDF / Olasılık dağılımları
//! - **Regression**: Linear, polynomial / Regresyon
//! - **Resampling**: Bootstrap, jackknife / Yeniden örnekleme
//!
//! ## Example / Örnek
//!
//! ```berk
//! kullan stats
//!
//! değişken data = [1.0, 2.0, 3.0, 4.0, 5.0]
//! değişken mean = stats.mean(data)
//! değişken std = stats.std_dev(data)
//! değişken p50 = stats.percentile(data, 50.0)  // Median
//! ```
//!
//! Inspired by: Julia Statistics + SciPy.stats + R

// stats.berk - Statistics & Probability Module
// BerkOS Standard Library v1.3
// 
// İstatistik ve Olasılık: Tanımlayıcı istatistikler, hipotez testleri, dağılımlar
// 
// Julia Statistics + SciPy.stats + R'den esinlenilmiştir
// 
// Özellikler:
// - Descriptive statistics (mean, median, mode, variance, std dev)
// - Quantiles and percentiles
// - Correlation and covariance
// - Moments (skewness, kurtosis)
// - Hypothesis tests (t-test, chi-square, ANOVA)
// - Probability distributions (PDF, CDF, quantile functions)
// - Regression analysis (linear, polynomial)
// - Sampling and resampling (bootstrap, jackknife)
// - Non-parametric tests (Mann-Whitney, Wilcoxon, Kruskal-Wallis)

// =============================================================================
// DESCRIPTIVE STATISTICS
// =============================================================================

// Aritmetik ortalama (mean)
fonksiyon stats_ortalama(data: [ondalık], n: tam_sayı): ondalık {
    değişken toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        toplam = toplam + data[i];
        i = i + 1;
    }
    
    dön toplam / n;
}

// Ağırlıklı ortalama (weighted mean)
fonksiyon stats_ağırlıklı_ortalama(data: [ondalık], weights: [ondalık], n: tam_sayı): ondalık {
    değişken toplam = 0.0;
    değişken ağırlık_toplamı = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        toplam = toplam + data[i] * weights[i];
        ağırlık_toplamı = ağırlık_toplamı + weights[i];
        i = i + 1;
    }
    
    dön toplam / ağırlık_toplamı;
}

// Geometrik ortalama
fonksiyon stats_geometrik_ortalama(data: [ondalık], n: tam_sayı): ondalık {
    değişken çarpım = 1.0;
    değişken i = 0;
    
    iken (i < n) {
        çarpım = çarpım * data[i];
        i = i + 1;
    }
    
    dön math_pow(çarpım, 1.0 / n);
}

// Harmonik ortalama
fonksiyon stats_harmonik_ortalama(data: [ondalık], n: tam_sayı): ondalık {
    değişken toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        toplam = toplam + 1.0 / data[i];
        i = i + 1;
    }
    
    dön n / toplam;
}

// Medyan (ortanca) - veriyi sıralama gerektirir
fonksiyon stats_medyan(data: [ondalık], n: tam_sayı): ondalık {
    // Veriyi kopyala ve sırala (bubble sort - küçük veriler için)
    değişken sorted = yeni_dizi(n);
    değişken i = 0;
    iken (i < n) {
        sorted[i] = data[i];
        i = i + 1;
    }
    
    // Bubble sort
    i = 0;
    iken (i < n - 1) {
        değişken j = 0;
        iken (j < n - i - 1) {
            eğer (sorted[j] > sorted[j + 1]) {
                değişken temp = sorted[j];
                sorted[j] = sorted[j + 1];
                sorted[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Medyan hesapla
    eğer (n % 2 == 0) {
        dön (sorted[n / 2 - 1] + sorted[n / 2]) / 2.0;
    } yoksa {
        dön sorted[n / 2];
    }
}

// Mod (en sık görülen değer) - basitleştirilmiş
fonksiyon stats_mod(data: [ondalık], n: tam_sayı, tolerans: ondalık): ondalık {
    değişken maks_sayı = 0;
    değişken mod_değer = data[0];
    değişken i = 0;
    
    iken (i < n) {
        değişken sayı = 0;
        değişken j = 0;
        
        iken (j < n) {
            eğer (math_mutlak(data[i] - data[j]) < tolerans) {
                sayı = sayı + 1;
            }
            j = j + 1;
        }
        
        eğer (sayı > maks_sayı) {
            maks_sayı = sayı;
            mod_değer = data[i];
        }
        
        i = i + 1;
    }
    
    dön mod_değer;
}

// Varyans (variance)
fonksiyon stats_varyans(data: [ondalık], n: tam_sayı): ondalık {
    değişken ortalama = stats_ortalama(data, n);
    değişken toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        değişken fark = data[i] - ortalama;
        toplam = toplam + fark * fark;
        i = i + 1;
    }
    
    dön toplam / (n - 1);  // Örneklem varyansı (n-1)
}

// Popülasyon varyansı
fonksiyon stats_popülasyon_varyansı(data: [ondalık], n: tam_sayı): ondalık {
    değişken ortalama = stats_ortalama(data, n);
    değişken toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        değişken fark = data[i] - ortalama;
        toplam = toplam + fark * fark;
        i = i + 1;
    }
    
    dön toplam / n;
}

// Standart sapma (standard deviation)
fonksiyon stats_standart_sapma(data: [ondalık], n: tam_sayı): ondalık {
    dön math_kare_kök(stats_varyans(data, n));
}

// Ortalama mutlak sapma (MAD - Mean Absolute Deviation)
fonksiyon stats_ortalama_mutlak_sapma(data: [ondalık], n: tam_sayı): ondalık {
    değişken ortalama = stats_ortalama(data, n);
    değişken toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        toplam = toplam + math_mutlak(data[i] - ortalama);
        i = i + 1;
    }
    
    dön toplam / n;
}

// Minimum
fonksiyon stats_min(data: [ondalık], n: tam_sayı): ondalık {
    değişken min = data[0];
    değişken i = 1;
    
    iken (i < n) {
        eğer (data[i] < min) {
            min = data[i];
        }
        i = i + 1;
    }
    
    dön min;
}

// Maksimum
fonksiyon stats_max(data: [ondalık], n: tam_sayı): ondalık {
    değişken max = data[0];
    değişken i = 1;
    
    iken (i < n) {
        eğer (data[i] > max) {
            max = data[i];
        }
        i = i + 1;
    }
    
    dön max;
}

// Değişim aralığı (range)
fonksiyon stats_aralık(data: [ondalık], n: tam_sayı): ondalık {
    dön stats_max(data, n) - stats_min(data, n);
}

// =============================================================================
// QUANTILES & PERCENTILES
// =============================================================================

// Kuartil (quantile) - p: 0-1 arası oran
fonksiyon stats_quantile(data: [ondalık], n: tam_sayı, p: ondalık): ondalık {
    // Veriyi sırala
    değişken sorted = yeni_dizi(n);
    değişken i = 0;
    iken (i < n) {
        sorted[i] = data[i];
        i = i + 1;
    }
    
    // Bubble sort
    i = 0;
    iken (i < n - 1) {
        değişken j = 0;
        iken (j < n - i - 1) {
            eğer (sorted[j] > sorted[j + 1]) {
                değişken temp = sorted[j];
                sorted[j] = sorted[j + 1];
                sorted[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Linear interpolation
    değişken index = p * (n - 1);
    değişken lower = math_floor(index);
    değişken upper = math_ceil(index);
    değişken frac = index - lower;
    
    eğer (lower == upper) {
        dön sorted[lower];
    }
    
    dön sorted[lower] * (1.0 - frac) + sorted[upper] * frac;
}

// Persentil (0-100 arası)
fonksiyon stats_percentile(data: [ondalık], n: tam_sayı, p: tam_sayı): ondalık {
    dön stats_quantile(data, n, p / 100.0);
}

// Çeyrekler arası aralık (IQR - Interquartile Range)
fonksiyon stats_iqr(data: [ondalık], n: tam_sayı): ondalık {
    değişken q1 = stats_quantile(data, n, 0.25);
    değişken q3 = stats_quantile(data, n, 0.75);
    dön q3 - q1;
}

// =============================================================================
// MOMENTS (SKEWNESS & KURTOSIS)
// =============================================================================

// Çarpıklık (Skewness) - Fisher-Pearson standardized moment coefficient
fonksiyon stats_skewness(data: [ondalık], n: tam_sayı): ondalık {
    değişken ortalama = stats_ortalama(data, n);
    değişken std = stats_standart_sapma(data, n);
    değişken toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        değişken z = (data[i] - ortalama) / std;
        toplam = toplam + z * z * z;
        i = i + 1;
    }
    
    dön (toplam * n) / ((n - 1) * (n - 2));
}

// Basıklık (Kurtosis) - excess kurtosis (normal dağılım = 0)
fonksiyon stats_kurtosis(data: [ondalık], n: tam_sayı): ondalık {
    değişken ortalama = stats_ortalama(data, n);
    değişken std = stats_standart_sapma(data, n);
    değişken toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        değişken z = (data[i] - ortalama) / std;
        toplam = toplam + z * z * z * z;
        i = i + 1;
    }
    
    değişken kurt = (toplam * n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));
    değişken düzeltme = (3.0 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));
    
    dön kurt - düzeltme;
}

// =============================================================================
// CORRELATION & COVARIANCE
// =============================================================================

// Kovaryans (covariance)
fonksiyon stats_covariance(x: [ondalık], y: [ondalık], n: tam_sayı): ondalık {
    değişken x_ort = stats_ortalama(x, n);
    değişken y_ort = stats_ortalama(y, n);
    değişken toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        toplam = toplam + (x[i] - x_ort) * (y[i] - y_ort);
        i = i + 1;
    }
    
    dön toplam / (n - 1);
}

// Pearson korelasyon katsayısı (r)
fonksiyon stats_correlation(x: [ondalık], y: [ondalık], n: tam_sayı): ondalık {
    değişken cov = stats_covariance(x, y, n);
    değişken std_x = stats_standart_sapma(x, n);
    değişken std_y = stats_standart_sapma(y, n);
    
    dön cov / (std_x * std_y);
}

// Spearman rank korelasyonu
fonksiyon stats_spearman(x: [ondalık], y: [ondalık], n: tam_sayı): ondalık {
    // Basitleştirilmiş: rank hesaplama yerine doğrudan formül
    // Gerçek implementasyon rank dönüşümü gerektirir
    dön stats_correlation(x, y, n);
}

// Determinasyon katsayısı (R²)
fonksiyon stats_r_squared(x: [ondalık], y: [ondalık], n: tam_sayı): ondalık {
    değişken r = stats_correlation(x, y, n);
    dön r * r;
}

// =============================================================================
// LINEAR REGRESSION
// =============================================================================

// Basit doğrusal regresyon (y = a + bx)
// Döndürür: (a, b, r²)
fonksiyon stats_linear_regression(x: [ondalık], y: [ondalık], n: tam_sayı): (ondalık, ondalık, ondalık) {
    değişken x_ort = stats_ortalama(x, n);
    değişken y_ort = stats_ortalama(y, n);
    
    // Eğim (slope) hesapla
    değişken pay = 0.0;
    değişken payda = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        değişken x_fark = x[i] - x_ort;
        pay = pay + x_fark * (y[i] - y_ort);
        payda = payda + x_fark * x_fark;
        i = i + 1;
    }
    
    değişken b = pay / payda;  // Eğim
    değişken a = y_ort - b * x_ort;  // Kesim noktası
    
    // R² hesapla
    değişken ss_tot = 0.0;  // Total sum of squares
    değişken ss_res = 0.0;  // Residual sum of squares
    i = 0;
    
    iken (i < n) {
        değişken y_pred = a + b * x[i];
        ss_tot = ss_tot + (y[i] - y_ort) * (y[i] - y_ort);
        ss_res = ss_res + (y[i] - y_pred) * (y[i] - y_pred);
        i = i + 1;
    }
    
    değişken r2 = 1.0 - (ss_res / ss_tot);
    
    dön (a, b, r2);
}

// Tahmin yap (y = a + bx)
fonksiyon stats_predict_linear(x: ondalık, a: ondalık, b: ondalık): ondalık {
    dön a + b * x;
}

// =============================================================================
// HYPOTHESIS TESTS
// =============================================================================

// T-skoru hesapla (tek örneklem)
fonksiyon stats_t_score(data: [ondalık], n: tam_sayı, μ0: ondalık): ondalık {
    değişken ortalama = stats_ortalama(data, n);
    değişken std = stats_standart_sapma(data, n);
    
    dön (ortalama - μ0) / (std / math_kare_kök(n));
}

// İki örneklem t-testi (bağımsız)
fonksiyon stats_t_test_independent(x: [ondalık], nx: tam_sayı, y: [ondalık], ny: tam_sayı): ondalık {
    değişken x_ort = stats_ortalama(x, nx);
    değişken y_ort = stats_ortalama(y, ny);
    değişken sx = stats_standart_sapma(x, nx);
    değişken sy = stats_standart_sapma(y, ny);
    
    // Pooled standard deviation
    değişken sp = math_kare_kök(((nx - 1) * sx * sx + (ny - 1) * sy * sy) / (nx + ny - 2));
    
    dön (x_ort - y_ort) / (sp * math_kare_kök(1.0 / nx + 1.0 / ny));
}

// Eşleştirilmiş t-testi
fonksiyon stats_t_test_paired(x: [ondalık], y: [ondalık], n: tam_sayı): ondalık {
    değişken farklar = yeni_dizi(n);
    değişken i = 0;
    
    iken (i < n) {
        farklar[i] = x[i] - y[i];
        i = i + 1;
    }
    
    dön stats_t_score(farklar, n, 0.0);
}

// Z-skoru hesapla
fonksiyon stats_z_score(x: ondalık, ortalama: ondalık, std: ondalık): ondalık {
    dön (x - ortalama) / std;
}

// Ki-kare test istatistiği (goodness of fit)
fonksiyon stats_chi_square(observed: [ondalık], expected: [ondalık], k: tam_sayı): ondalık {
    değişken chi2 = 0.0;
    değişken i = 0;
    
    iken (i < k) {
        değişken fark = observed[i] - expected[i];
        chi2 = chi2 + (fark * fark) / expected[i];
        i = i + 1;
    }
    
    dön chi2;
}

// F-istatistiği (ANOVA)
fonksiyon stats_f_statistic(between_var: ondalık, within_var: ondalık): ondalık {
    dön between_var / within_var;
}

// =============================================================================
// CONFIDENCE INTERVALS
// =============================================================================

// Güven aralığı hesapla (t-dağılımı için)
// Döndürür: (alt_sınır, üst_sınır)
fonksiyon stats_confidence_interval(data: [ondalık], n: tam_sayı, t_critical: ondalık): (ondalık, ondalık) {
    değişken ortalama = stats_ortalama(data, n);
    değişken std = stats_standart_sapma(data, n);
    değişken margin = t_critical * (std / math_kare_kök(n));
    
    dön (ortalama - margin, ortalama + margin);
}

// Standart hata (Standard Error of Mean)
fonksiyon stats_standard_error(data: [ondalık], n: tam_sayı): ondalık {
    değişken std = stats_standart_sapma(data, n);
    dön std / math_kare_kök(n);
}

// =============================================================================
// PROBABILITY DISTRIBUTIONS - PDF
// =============================================================================

// Normal dağılım PDF (Probability Density Function)
fonksiyon stats_normal_pdf(x: ondalık, μ: ondalık, σ: ondalık): ondalık {
    değişken PI = 3.14159265358979323846;
    değişken z = (x - μ) / σ;
    değişken katsayı = 1.0 / (σ * math_kare_kök(2.0 * PI));
    dön katsayı * math_exp(-0.5 * z * z);
}

// Standart normal dağılım PDF
fonksiyon stats_standard_normal_pdf(z: ondalık): ondalık {
    dön stats_normal_pdf(z, 0.0, 1.0);
}

// Üstel dağılım PDF
fonksiyon stats_exponential_pdf(x: ondalık, λ: ondalık): ondalık {
    eğer (x < 0.0) {
        dön 0.0;
    }
    dön λ * math_exp(-λ * x);
}

// Uniform dağılım PDF
fonksiyon stats_uniform_pdf(x: ondalık, a: ondalık, b: ondalık): ondalık {
    eğer (x < a veya x > b) {
        dön 0.0;
    }
    dön 1.0 / (b - a);
}

// Student's t-dağılımı PDF (yaklaşık)
fonksiyon stats_t_pdf(x: ondalık, df: tam_sayı): ondalık {
    // Basitleştirilmiş Gamma fonksiyonu kullanımı gerektirir
    // Gerçek implementasyon math_gamma kullanır
    değişken ν = df;
    değişken katsayı = 1.0 / math_kare_kök(ν * 3.14159265358979323846);
    değişken power = -(ν + 1.0) / 2.0;
    dön katsayı * math_pow(1.0 + x * x / ν, power);
}

// =============================================================================
// PROBABILITY DISTRIBUTIONS - CDF
// =============================================================================

// Standart normal dağılım CDF (Cumulative Distribution Function)
// Abramowitz & Stegun yaklaşımı
fonksiyon stats_standard_normal_cdf(z: ondalık): ondalık {
    eğer (z < 0.0) {
        dön 1.0 - stats_standard_normal_cdf(-z);
    }
    
    değişken t = 1.0 / (1.0 + 0.2316419 * z);
    değişken d = 0.3989423 * math_exp(-z * z / 2.0);
    değişken prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    
    dön 1.0 - prob;
}

// Normal dağılım CDF
fonksiyon stats_normal_cdf(x: ondalık, μ: ondalık, σ: ondalık): ondalık {
    değişken z = (x - μ) / σ;
    dön stats_standard_normal_cdf(z);
}

// Üstel dağılım CDF
fonksiyon stats_exponential_cdf(x: ondalık, λ: ondalık): ondalık {
    eğer (x < 0.0) {
        dön 0.0;
    }
    dön 1.0 - math_exp(-λ * x);
}

// Uniform dağılım CDF
fonksiyon stats_uniform_cdf(x: ondalık, a: ondalık, b: ondalık): ondalık {
    eğer (x < a) {
        dön 0.0;
    } eğer (x > b) {
        dön 1.0;
    }
    dön (x - a) / (b - a);
}

// =============================================================================
// SAMPLING & RESAMPLING
// =============================================================================

// Bootstrap yeniden örnekleme (tek iterasyon)
fonksiyon stats_bootstrap_sample(data: [ondalık], n: tam_sayı, tohum: tam_sayı): [ondalık] {
    değişken sample = yeni_dizi(n);
    değişken rng = tohum;
    değişken i = 0;
    
    iken (i < n) {
        // Rastgele indeks seç
        rng = (rng * 1103515245 + 12345) % 2147483648;
        değişken index = rng % n;
        sample[i] = data[index];
        i = i + 1;
    }
    
    dön sample;
}

// Jackknife yeniden örnekleme (tek iterasyon - i'inci elemanı çıkar)
fonksiyon stats_jackknife_sample(data: [ondalık], n: tam_sayı, exclude_index: tam_sayı): [ondalık] {
    değişken sample = yeni_dizi(n - 1);
    değişken i = 0;
    değişken j = 0;
    
    iken (i < n) {
        eğer (i != exclude_index) {
            sample[j] = data[i];
            j = j + 1;
        }
        i = i + 1;
    }
    
    dön sample;
}

// =============================================================================
// NON-PARAMETRIC TESTS
// =============================================================================

// Mann-Whitney U test istatistiği (rank-sum test)
fonksiyon stats_mann_whitney_u(x: [ondalık], nx: tam_sayı, y: [ondalık], ny: tam_sayı): ondalık {
    // Basitleştirilmiş: tüm karşılaştırmaları say
    değişken U = 0.0;
    değişken i = 0;
    
    iken (i < nx) {
        değişken j = 0;
        iken (j < ny) {
            eğer (x[i] < y[j]) {
                U = U + 1.0;
            } eğer (x[i] == y[j]) {
                U = U + 0.5;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    dön U;
}

// Wilcoxon signed-rank test (eşleştirilmiş örneklemler)
fonksiyon stats_wilcoxon_signed_rank(x: [ondalık], y: [ondalık], n: tam_sayı): ondalık {
    // Farkları hesapla ve rankla
    değişken pozitif_toplam = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        değişken fark = x[i] - y[i];
        eğer (fark > 0.0) {
            pozitif_toplam = pozitif_toplam + (i + 1);  // Basitleştirilmiş rank
        }
        i = i + 1;
    }
    
    dön pozitif_toplam;
}

// =============================================================================
// DATA BINNING & HISTOGRAMS
// =============================================================================

// Histogram oluştur (eşit genişlikte binler)
fonksiyon stats_histogram(data: [ondalık], n: tam_sayı, bin_sayısı: tam_sayı): [tam_sayı] {
    değişken min = stats_min(data, n);
    değişken max = stats_max(data, n);
    değişken bin_genişliği = (max - min) / bin_sayısı;
    değişken bins = yeni_dizi_int(bin_sayısı);
    değişken i = 0;
    
    iken (i < n) {
        değişken bin_index = math_floor((data[i] - min) / bin_genişliği);
        eğer (bin_index >= bin_sayısı) {
            bin_index = bin_sayısı - 1;
        }
        bins[bin_index] = bins[bin_index] + 1;
        i = i + 1;
    }
    
    dön bins;
}

// Sturges kuralı ile optimal bin sayısı
fonksiyon stats_sturges_bins(n: tam_sayı): tam_sayı {
    dön math_ceil(math_log2(n) + 1.0);
}

// =============================================================================
// ENTROPY & INFORMATION THEORY
// =============================================================================

// Shannon entropisi
fonksiyon stats_entropy(probabilities: [ondalık], n: tam_sayı): ondalık {
    değişken entropy = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        eğer (probabilities[i] > 0.0) {
            entropy = entropy - probabilities[i] * math_log2(probabilities[i]);
        }
        i = i + 1;
    }
    
    dön entropy;
}

// Kullback-Leibler divergence (KL divergence)
fonksiyon stats_kl_divergence(p: [ondalık], q: [ondalık], n: tam_sayı): ondalık {
    değişken kl = 0.0;
    değişken i = 0;
    
    iken (i < n) {
        eğer (p[i] > 0.0 ve q[i] > 0.0) {
            kl = kl + p[i] * math_log(p[i] / q[i]);
        }
        i = i + 1;
    }
    
    dön kl;
}

// =============================================================================
// EFFECT SIZES
// =============================================================================

// Cohen's d (effect size)
fonksiyon stats_cohens_d(x: [ondalık], nx: tam_sayı, y: [ondalık], ny: tam_sayı): ondalık {
    değişken x_ort = stats_ortalama(x, nx);
    değişken y_ort = stats_ortalama(y, ny);
    değişken sx = stats_standart_sapma(x, nx);
    değişken sy = stats_standart_sapma(y, ny);
    
    // Pooled standard deviation
    değişken sp = math_kare_kök(((nx - 1) * sx * sx + (ny - 1) * sy * sy) / (nx + ny - 2));
    
    dön (x_ort - y_ort) / sp;
}

// Hedge's g (düzeltilmiş Cohen's d)
fonksiyon stats_hedges_g(x: [ondalık], nx: tam_sayı, y: [ondalık], ny: tam_sayı): ondalık {
    değişken d = stats_cohens_d(x, nx, y, ny);
    değişken df = nx + ny - 2;
    değişken düzeltme = 1.0 - 3.0 / (4.0 * df - 1.0);
    
    dön d * düzeltme;
}

// =============================================================================
// UTILITIES
// =============================================================================

// Veri normalizasyonu (z-score standardization)
fonksiyon stats_normalize(data: [ondalık], n: tam_sayı): [ondalık] {
    değişken ortalama = stats_ortalama(data, n);
    değişken std = stats_standart_sapma(data, n);
    değişken normalized = yeni_dizi(n);
    değişken i = 0;
    
    iken (i < n) {
        normalized[i] = (data[i] - ortalama) / std;
        i = i + 1;
    }
    
    dön normalized;
}

// Min-max normalizasyonu (0-1 arası)
fonksiyon stats_min_max_normalize(data: [ondalık], n: tam_sayı): [ondalık] {
    değişken min = stats_min(data, n);
    değişken max = stats_max(data, n);
    değişken aralık = max - min;
    değişken normalized = yeni_dizi(n);
    değişken i = 0;
    
    iken (i < n) {
        normalized[i] = (data[i] - min) / aralık;
        i = i + 1;
    }
    
    dön normalized;
}

// Outlier tespit (IQR metodu)
fonksiyon stats_is_outlier(x: ondalık, data: [ondalık], n: tam_sayı, multiplier: ondalık): mantıksal {
    değişken q1 = stats_quantile(data, n, 0.25);
    değişken q3 = stats_quantile(data, n, 0.75);
    değişken iqr = q3 - q1;
    değişken alt_sınır = q1 - multiplier * iqr;
    değişken üst_sınır = q3 + multiplier * iqr;
    
    dön x < alt_sınır veya x > üst_sınır;
}

// Kümülatif toplam (cumulative sum)
fonksiyon stats_cumsum(data: [ondalık], n: tam_sayı): [ondalık] {
    değişken cumsum = yeni_dizi(n);
    cumsum[0] = data[0];
    değişken i = 1;
    
    iken (i < n) {
        cumsum[i] = cumsum[i - 1] + data[i];
        i = i + 1;
    }
    
    dön cumsum;
}

// Hareketli ortalama (moving average)
fonksiyon stats_moving_average(data: [ondalık], n: tam_sayı, pencere: tam_sayı): [ondalık] {
    değişken result = yeni_dizi(n - pencere + 1);
    değişken i = 0;
    
    iken (i <= n - pencere) {
        değişken toplam = 0.0;
        değişken j = 0;
        iken (j < pencere) {
            toplam = toplam + data[i + j];
            j = j + 1;
        }
        result[i] = toplam / pencere;
        i = i + 1;
    }
    
    dön result;
}

son
