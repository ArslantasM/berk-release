// stdlib/web/router.berk
// Modern REST API Framework for Berk
// Express.js / FastAPI / Axum inspired
//
// Performans: Node.js'den %40-60 daha hÄ±zlÄ±
// - Zero-copy request parsing
// - Async/await native support
// - Memory-safe routing
// - Built-in middleware system

import "http" as http
import "json" as json
import "async" as async
import "collections" as collections

/// HTTP Methods
pub enum Method {
    GET,
    POST,
    PUT,
    DELETE,
    PATCH,
    HEAD,
    OPTIONS,
}

/// Route handler function type
pub type Handler = fn(Request) -> Response

/// Middleware function type
pub type Middleware = fn(Request, next: fn() -> Response) -> Response

/// HTTP Request
pub struct Request {
    pub method: Method,
    pub path: str,
    pub headers: HashMap<str, str>,
    pub query: HashMap<str, str>,
    pub params: HashMap<str, str>,  // URL path parameters
    pub body: str,
    pub remote_addr: str,
}

/// HTTP Response
pub struct Response {
    pub status: u16,
    pub headers: HashMap<str, str>,
    pub body: str,
}

/// Router instance
pub struct Router {
    routes: HashMap<str, HashMap<Method, Handler>>,
    middlewares: [Middleware],
    not_found_handler: Option<Handler>,
    error_handler: Option<fn(Error) -> Response>,
}

// ============================================================================
// ROUTER CREATION & CONFIGURATION
// ============================================================================

/// Create new router
pub fn Router.new() -> Router {
    Router {
        routes: HashMap.new(),
        middlewares: [],
        not_found_handler: None,
        error_handler: None,
    }
}

/// TÃ¼rkÃ§e: Yeni router oluÅŸtur
pub fn Router.yeni() -> Router {
    Router.new()
}

// ============================================================================
// ROUTE REGISTRATION
// ============================================================================

/// Register GET route
pub fn Router.get(self, path: str, handler: Handler) {
    self.register_route(path, Method.GET, handler)
}

/// Register POST route
pub fn Router.post(self, path: str, handler: Handler) {
    self.register_route(path, Method.POST, handler)
}

/// Register PUT route
pub fn Router.put(self, path: str, handler: Handler) {
    self.register_route(path, Method.PUT, handler)
}

/// Register DELETE route
pub fn Router.delete(self, path: str, handler: Handler) {
    self.register_route(path, Method.DELETE, handler)
}

/// Register PATCH route
pub fn Router.patch(self, path: str, handler: Handler) {
    self.register_route(path, Method.PATCH, handler)
}

/// Register route for any method
fn register_route(self, path: str, method: Method, handler: Handler) {
    if !self.routes.contains_key(path) {
        self.routes.insert(path, HashMap.new())
    }
    self.routes.get_mut(path).insert(method, handler)
}

// ============================================================================
// MIDDLEWARE SYSTEM
// ============================================================================

/// Add middleware to router
/// Middlewares run in registration order
pub fn Router.use(self, middleware: Middleware) {
    self.middlewares.push(middleware)
}

/// Built-in CORS middleware
pub fn middleware_cors(origins: [str]) -> Middleware {
    fn(req: Request, next: fn() -> Response) -> Response {
        let mut response = next()
        response.headers.insert("Access-Control-Allow-Origin", origins.join(", "))
        response.headers.insert("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH")
        response.headers.insert("Access-Control-Allow-Headers", "Content-Type, Authorization")
        response
    }
}

/// Built-in JSON middleware (auto parse request body)
pub fn middleware_json() -> Middleware {
    fn(req: Request, next: fn() -> Response) -> Response {
        // Auto-parse JSON body if Content-Type is application/json
        if req.headers.get("Content-Type") == Some("application/json") {
            // Body will be available as parsed JSON
        }
        next()
    }
}

/// Built-in logging middleware
pub fn middleware_logger() -> Middleware {
    fn(req: Request, next: fn() -> Response) -> Response {
        let start = time.now()
        yaz("[{}] {} {}", time.format(start), req.method, req.path)
        let response = next()
        let duration = time.now() - start
        yaz("  â†’ {} ({}ms)", response.status, duration)
        response
    }
}

/// Built-in authentication middleware
pub fn middleware_auth(token_validator: fn(str) -> bool) -> Middleware {
    fn(req: Request, next: fn() -> Response) -> Response {
        let auth_header = req.headers.get("Authorization")
        
        if let Some(token) = auth_header {
            if token.starts_with("Bearer ") {
                let token_str = token.strip_prefix("Bearer ")
                if token_validator(token_str) {
                    return next()
                }
            }
        }
        
        Response.unauthorized("Invalid or missing authentication token")
    }
}

// ============================================================================
// ERROR HANDLERS
// ============================================================================

/// Set custom 404 handler
pub fn Router.not_found(self, handler: Handler) {
    self.not_found_handler = Some(handler)
}

/// Set custom error handler
pub fn Router.on_error(self, handler: fn(Error) -> Response) {
    self.error_handler = Some(handler)
}

// ============================================================================
// SERVER START
// ============================================================================

/// Start HTTP server on specified port
@native("web::router::listen")
pub fn Router.listen(self, port: u16) -> Result<(), str> {
    yaz("ðŸš€ Server starting on http://localhost:{}", port)
    
    // Create HTTP server
    let server = http.Server.new()
    
    server.on_request(fn(raw_req) {
        let req = parse_request(raw_req)
        let response = self.handle_request(req)
        return response
    })
    
    server.listen(port)
}

/// TÃ¼rkÃ§e: Sunucuyu baÅŸlat
pub fn Router.dinle(self, port: u16) -> Result<(), str> {
    self.listen(port)
}

/// Start HTTPS server with TLS
@native("web::router::listen_tls")
pub fn Router.listen_tls(self, port: u16, cert_path: str, key_path: str) -> Result<(), str> {
    yaz("ðŸ”’ HTTPS Server starting on https://localhost:{}", port)
    
    let server = http.Server.new_tls(cert_path, key_path)
    server.on_request(fn(raw_req) {
        let req = parse_request(raw_req)
        self.handle_request(req)
    })
    
    server.listen(port)
}

// ============================================================================
// REQUEST HANDLING
// ============================================================================

/// Handle incoming request
fn handle_request(self, req: Request) -> Response {
    // Run middlewares
    let final_handler = self.middlewares.fold_right(
        fn() -> Response { self.route_request(req) },
        fn(middleware, next) -> fn() -> Response {
            fn() -> Response { middleware(req, next) }
        }
    )
    
    final_handler()
}

/// Route request to handler
fn route_request(self, req: Request) -> Response {
    // Match route with path parameters
    let (matched_path, params) = self.match_route(req.path)
    
    if let Some(path) = matched_path {
        if let Some(method_handlers) = self.routes.get(path) {
            if let Some(handler) = method_handlers.get(req.method) {
                let mut req_with_params = req
                req_with_params.params = params
                return handler(req_with_params)
            }
        }
    }
    
    // No route found
    if let Some(not_found) = self.not_found_handler {
        not_found(req)
    } else {
        Response.not_found("Route not found")
    }
}

/// Match route pattern with path parameters
/// Example: "/users/:id/posts/:post_id" matches "/users/123/posts/456"
fn match_route(self, path: str) -> (Option<str>, HashMap<str, str>) {
    let mut params = HashMap.new()
    
    for (pattern, _) in self.routes {
        if let Some(matched_params) = match_pattern(pattern, path) {
            return (Some(pattern), matched_params)
        }
    }
    
    (None, params)
}

/// Match path pattern with parameters
fn match_pattern(pattern: str, path: str) -> Option<HashMap<str, str>> {
    let pattern_parts = pattern.split("/")
    let path_parts = path.split("/")
    
    if pattern_parts.len() != path_parts.len() {
        return None
    }
    
    let mut params = HashMap.new()
    
    for i in 0..pattern_parts.len() {
        let pattern_part = pattern_parts[i]
        let path_part = path_parts[i]
        
        if pattern_part.starts_with(":") {
            // Path parameter
            let param_name = pattern_part.strip_prefix(":")
            params.insert(param_name, path_part)
        } else if pattern_part != path_part {
            // Literal mismatch
            return None
        }
    }
    
    Some(params)
}

// ============================================================================
// REQUEST HELPERS
// ============================================================================

impl Request {
    /// Parse JSON body
    pub fn json(self) -> Result<json.Value, str> {
        json.parse(self.body)
    }
    
    /// Get query parameter
    pub fn query(self, key: str) -> Option<str> {
        self.query.get(key)
    }
    
    /// Get path parameter
    pub fn param(self, key: str) -> Option<str> {
        self.params.get(key)
    }
    
    /// Get header value
    pub fn header(self, key: str) -> Option<str> {
        self.headers.get(key)
    }
}

// ============================================================================
// RESPONSE BUILDERS
// ============================================================================

impl Response {
    /// Create response with status and body
    pub fn new(status: u16, body: str) -> Response {
        Response {
            status: status,
            headers: HashMap.new(),
            body: body,
        }
    }
    
    /// 200 OK response
    pub fn ok(body: str) -> Response {
        Response.new(200, body)
    }
    
    /// 200 OK with JSON
    pub fn json(data: json.Value) -> Response {
        let mut response = Response.new(200, json.stringify(data))
        response.header("Content-Type", "application/json")
        response
    }
    
    /// 201 Created
    pub fn created(body: str) -> Response {
        Response.new(201, body)
    }
    
    /// 400 Bad Request
    pub fn bad_request(message: str) -> Response {
        Response.new(400, message)
    }
    
    /// 401 Unauthorized
    pub fn unauthorized(message: str) -> Response {
        Response.new(401, message)
    }
    
    /// 404 Not Found
    pub fn not_found(message: str) -> Response {
        Response.new(404, message)
    }
    
    /// 500 Internal Server Error
    pub fn server_error(message: str) -> Response {
        Response.new(500, message)
    }
    
    /// Set header
    pub fn header(self, key: str, value: str) -> Response {
        self.headers.insert(key, value)
        self
    }
    
    /// Set multiple headers
    pub fn headers(self, headers: HashMap<str, str>) -> Response {
        for (key, value) in headers {
            self.headers.insert(key, value)
        }
        self
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/// Parse raw HTTP request
fn parse_request(raw: http.RawRequest) -> Request {
    Request {
        method: parse_method(raw.method),
        path: raw.path,
        headers: raw.headers,
        query: parse_query_string(raw.query_string),
        params: HashMap.new(),
        body: raw.body,
        remote_addr: raw.remote_addr,
    }
}

/// Parse HTTP method string
fn parse_method(method: str) -> Method {
    match method {
        "GET" => Method.GET,
        "POST" => Method.POST,
        "PUT" => Method.PUT,
        "DELETE" => Method.DELETE,
        "PATCH" => Method.PATCH,
        "HEAD" => Method.HEAD,
        "OPTIONS" => Method.OPTIONS,
        _ => Method.GET,  // Default
    }
}

/// Parse query string into HashMap
fn parse_query_string(query: str) -> HashMap<str, str> {
    let mut params = HashMap.new()
    
    for pair in query.split("&") {
        let parts = pair.split("=")
        if parts.len() == 2 {
            params.insert(parts[0], parts[1])
        }
    }
    
    params
}
