// stdlib/embedded/platforms/esp32/spi.berk
// ESP32 SPI HAL Implementation
// ESP-IDF SPI driver bindings

import "embedded/bal/spi" as SPI

// ESP-IDF SPI constants
const SPI2_HOST: u32 = 1  // HSPI
const SPI3_HOST: u32 = 2  // VSPI

const SPI_DEVICE_HALFDUPLEX: u32 = 1 << 0
const SPI_DEVICE_3WIRE: u32 = 1 << 1
const SPI_DEVICE_POSITIVE_CS: u32 = 1 << 2
const SPI_DEVICE_NO_DUMMY: u32 = 1 << 3

// ESP-IDF SPI structures
struct spi_bus_config_t {
    mosi_io_num: i32,
    miso_io_num: i32,
    sclk_io_num: i32,
    quadwp_io_num: i32,
    quadhd_io_num: i32,
    max_transfer_sz: i32,
    flags: u32,
}

struct spi_device_interface_config_t {
    command_bits: u8,
    address_bits: u8,
    dummy_bits: u8,
    mode: u8,
    duty_cycle_pos: u16,
    cs_ena_pretrans: u16,
    cs_ena_posttrans: u8,
    clock_speed_hz: i32,
    input_delay_ns: i32,
    spics_io_num: i32,
    flags: u32,
    queue_size: i32,
    pre_cb: *mut void,
    post_cb: *mut void,
}

struct spi_transaction_t {
    flags: u32,
    cmd: u16,
    addr: u64,
    length: u32,
    rxlength: u32,
    user: *mut void,
    tx_buffer: *u8,
    rx_buffer: *mut u8,
}

// ESP-IDF SPI functions
extern "C" {
    fn spi_bus_initialize(host: u32, bus_config: *spi_bus_config_t, dma_chan: i32) -> i32
    fn spi_bus_free(host: u32) -> i32
    fn spi_bus_add_device(host: u32, dev_config: *spi_device_interface_config_t, handle: *mut *mut void) -> i32
    fn spi_bus_remove_device(handle: *mut void) -> i32
    fn spi_device_transmit(handle: *mut void, trans_desc: *spi_transaction_t) -> i32
    fn spi_device_polling_transmit(handle: *mut void, trans_desc: *spi_transaction_t) -> i32
    fn spi_device_acquire_bus(device: *mut void, wait: u32) -> i32
    fn spi_device_release_bus(dev: *mut void)
}

const ESP_OK: i32 = 0
const SPI_DMA_CH_AUTO: i32 = 3

// Device handle storage
static mut device_handles: [*mut void; 2] = [null; 2]

// ESP32 SPI HAL implementation
pub struct ESP32_SPI {}

impl SPI.SPI_HAL for ESP32_SPI {
    fn init(config: SPI.Config) -> SPI.Result<()> {
        let host = if config.bus == 0 {
            SPI2_HOST  // HSPI
        } else {
            SPI3_HOST  // VSPI
        }
        
        // Configure SPI bus
        let bus_conf = spi_bus_config_t {
            mosi_io_num: config.mosi_pin as i32,
            miso_io_num: config.miso_pin as i32,
            sclk_io_num: config.sck_pin as i32,
            quadwp_io_num: -1,
            quadhd_io_num: -1,
            max_transfer_sz: 4096,
            flags: 0,
        }
        
        let ret = spi_bus_initialize(host, &bus_conf, SPI_DMA_CH_AUTO)
        if ret != ESP_OK {
            return Err(SPI.Error.BusError)
        }
        
        // Configure SPI device
        let mode_val = match config.mode {
            SPI.Mode.Mode0 => 0,
            SPI.Mode.Mode1 => 1,
            SPI.Mode.Mode2 => 2,
            SPI.Mode.Mode3 => 3,
        }
        
        let flags = if config.cs_active_low {
            0
        } else {
            SPI_DEVICE_POSITIVE_CS
        }
        
        let dev_conf = spi_device_interface_config_t {
            command_bits: 0,
            address_bits: 0,
            dummy_bits: 0,
            mode: mode_val,
            duty_cycle_pos: 128,
            cs_ena_pretrans: 0,
            cs_ena_posttrans: 0,
            clock_speed_hz: config.frequency as i32,
            input_delay_ns: 0,
            spics_io_num: config.cs_pin as i32,
            flags: flags,
            queue_size: 7,
            pre_cb: null,
            post_cb: null,
        }
        
        unsafe {
            let ret = spi_bus_add_device(host, &dev_conf, &mut device_handles[config.bus as usize])
            if ret != ESP_OK {
                return Err(SPI.Error.BusError)
            }
        }
        
        Ok(())
    }
    
    fn deinit(bus: u8) {
        unsafe {
            if device_handles[bus as usize] != null {
                spi_bus_remove_device(device_handles[bus as usize])
                device_handles[bus as usize] = null
            }
        }
        
        let host = if bus == 0 { SPI2_HOST } else { SPI3_HOST }
        spi_bus_free(host)
    }
    
    fn transfer_byte(bus: u8, data: u8) -> SPI.Result<u8> {
        let mut tx_data: [u8; 1] = [data]
        let mut rx_data: [u8; 1] = [0]
        
        ESP32_SPI.transfer(bus, &tx_data, &mut rx_data)?
        Ok(rx_data[0])
    }
    
    fn transfer(bus: u8, write_data: &[u8], read_buffer: &mut [u8]) -> SPI.Result<()> {
        unsafe {
            if device_handles[bus as usize] == null {
                return Err(SPI.Error.BusError)
            }
            
            let length = if write_data.len() < read_buffer.len() {
                write_data.len()
            } else {
                read_buffer.len()
            }
            
            let trans = spi_transaction_t {
                flags: 0,
                cmd: 0,
                addr: 0,
                length: (length * 8) as u32,  // in bits
                rxlength: (length * 8) as u32,
                user: null,
                tx_buffer: write_data.as_ptr(),
                rx_buffer: read_buffer.as_mut_ptr(),
            }
            
            let ret = spi_device_polling_transmit(device_handles[bus as usize], &trans)
            
            if ret == ESP_OK {
                Ok(())
            } else {
                Err(SPI.Error.Timeout)
            }
        }
    }
    
    fn write(bus: u8, data: &[u8]) -> SPI.Result<()> {
        unsafe {
            if device_handles[bus as usize] == null {
                return Err(SPI.Error.BusError)
            }
            
            let trans = spi_transaction_t {
                flags: 0,
                cmd: 0,
                addr: 0,
                length: (data.len() * 8) as u32,
                rxlength: 0,
                user: null,
                tx_buffer: data.as_ptr(),
                rx_buffer: null,
            }
            
            let ret = spi_device_polling_transmit(device_handles[bus as usize], &trans)
            
            if ret == ESP_OK {
                Ok(())
            } else {
                Err(SPI.Error.Timeout)
            }
        }
    }
    
    fn read(bus: u8, buffer: &mut [u8]) -> SPI.Result<()> {
        unsafe {
            if device_handles[bus as usize] == null {
                return Err(SPI.Error.BusError)
            }
            
            let trans = spi_transaction_t {
                flags: 0,
                cmd: 0,
                addr: 0,
                length: 0,
                rxlength: (buffer.len() * 8) as u32,
                user: null,
                tx_buffer: null,
                rx_buffer: buffer.as_mut_ptr(),
            }
            
            let ret = spi_device_polling_transmit(device_handles[bus as usize], &trans)
            
            if ret == ESP_OK {
                Ok(())
            } else {
                Err(SPI.Error.Timeout)
            }
        }
    }
    
    fn select(bus: u8, cs_pin: u8) {
        // ESP-IDF handles CS automatically
        unsafe {
            if device_handles[bus as usize] != null {
                spi_device_acquire_bus(device_handles[bus as usize], 0xFFFFFFFF)
            }
        }
    }
    
    fn deselect(bus: u8, cs_pin: u8) {
        // ESP-IDF handles CS automatically
        unsafe {
            if device_handles[bus as usize] != null {
                spi_device_release_bus(device_handles[bus as usize])
            }
        }
    }
    
    fn set_frequency(bus: u8, frequency: u32) -> SPI.Result<()> {
        // ESP32 requires removing and re-adding device to change frequency
        Err(SPI.Error.BusError)
    }
    
    fn set_mode(bus: u8, mode: SPI.Mode) -> SPI.Result<()> {
        // ESP32 requires removing and re-adding device to change mode
        Err(SPI.Error.BusError)
    }
}

// ESP32-specific SPI functions

/// Initialize SPI for SD card (high-speed, mode 0)
pub fn init_sd_card(bus: u8, sck: u8, mosi: u8, miso: u8, cs: u8) -> SPI.Result<()> {
    let config = SPI.Config {
        bus: bus,
        sck_pin: sck,
        mosi_pin: mosi,
        miso_pin: miso,
        cs_pin: cs,
        frequency: 20_000_000,  // 20 MHz
        mode: SPI.Mode.Mode0,
        bit_order: SPI.BitOrder.MSBFirst,
        data_size: SPI.DataSize.Bits8,
        cs_active_low: true,
    }
    ESP32_SPI.init(config)
}

/// Initialize SPI for LCD display (high-speed, mode 0)
pub fn init_lcd(bus: u8, sck: u8, mosi: u8, cs: u8, dc: u8) -> SPI.Result<()> {
    let config = SPI.Config {
        bus: bus,
        sck_pin: sck,
        mosi_pin: mosi,
        miso_pin: 255,  // No MISO for display
        cs_pin: cs,
        frequency: 40_000_000,  // 40 MHz
        mode: SPI.Mode.Mode0,
        bit_order: SPI.BitOrder.MSBFirst,
        data_size: SPI.DataSize.Bits8,
        cs_active_low: true,
    }
    ESP32_SPI.init(config)
}

/// Get SPI bus maximum frequency
pub fn get_max_frequency(bus: u8) -> u32 {
    80_000_000  // ESP32 APB clock (80MHz max for SPI)
}

/// Check if DMA is enabled
pub fn is_dma_enabled(bus: u8) -> bool {
    true  // Always enabled when using SPI_DMA_CH_AUTO
}
