// RP2040 UART Module
// Hardware Abstraction Layer for RP2040's UART peripheral
// 
// RP2040 Features:
// - 2x UART interfaces (UART0, UART1)
// - Programmable baud rate generator
// - Supports standard rates: 300 to 3 Mbaud
// - 32 x 8 character TX/RX FIFOs
// - Programmable hardware flow control (RTS/CTS)
// - Supports 5, 6, 7, or 8 data bits
// - Optional parity bit
// - 1 or 2 stop bits
// - Break generation and detection
//
// Pico SDK: hardware_uart

extern "C" {
    // Pico SDK UART Functions
    fn uart_init(uart: *void, baudrate: u32) -> u32;
    fn uart_deinit(uart: *void);
    fn uart_set_baudrate(uart: *void, baudrate: u32) -> u32;
    fn uart_set_hw_flow(uart: *void, cts: bool, rts: bool);
    fn uart_set_format(uart: *void, data_bits: u32, stop_bits: u32, parity: u32);
    fn uart_set_fifo_enabled(uart: *void, enabled: bool);
    
    fn uart_is_writable(uart: *void) -> bool;
    fn uart_is_readable(uart: *void) -> bool;
    fn uart_putc_raw(uart: *void, c: u8);
    fn uart_putc(uart: *void, c: u8);
    fn uart_puts(uart: *void, s: *const u8);
    fn uart_getc(uart: *void) -> u8;
    
    fn uart_write_blocking(uart: *void, src: *const u8, len: u32);
    fn uart_read_blocking(uart: *void, dst: *u8, len: u32);
    
    fn uart_is_enabled(uart: *void) -> bool;
    fn uart_set_break(uart: *void, en: bool);
    fn uart_set_translate_crlf(uart: *void, translate: bool);
    
    fn uart_get_dreq(uart: *void, is_tx: bool) -> u32;
    
    // GPIO Functions
    fn gpio_set_function(gpio: u32, fn_code: u32);
    
    // Hardware addresses
    const UART0_BASE: *void = 0x40034000 as *void;
    const UART1_BASE: *void = 0x40038000 as *void;
}

// GPIO Function codes for UART
const GPIO_FUNC_UART: u32 = 2;

// Default UART0 pins for Pico board
const PICO_DEFAULT_UART_TX_PIN: u32 = 0;  // GP0 (UART0 TX)
const PICO_DEFAULT_UART_RX_PIN: u32 = 1;  // GP1 (UART0 RX)

// UART1 alternative pins
const UART1_TX_PIN: u32 = 4;  // GP4
const UART1_RX_PIN: u32 = 5;  // GP5

// UART configuration constants
const UART_DATA_BITS_5: u32 = 5;
const UART_DATA_BITS_6: u32 = 6;
const UART_DATA_BITS_7: u32 = 7;
const UART_DATA_BITS_8: u32 = 8;

const UART_STOP_BITS_1: u32 = 1;
const UART_STOP_BITS_2: u32 = 2;

const UART_PARITY_NONE: u32 = 0;
const UART_PARITY_EVEN: u32 = 1;
const UART_PARITY_ODD: u32 = 2;

// Standard baud rates
const UART_BAUD_9600: u32 = 9600;
const UART_BAUD_19200: u32 = 19200;
const UART_BAUD_38400: u32 = 38400;
const UART_BAUD_57600: u32 = 57600;
const UART_BAUD_115200: u32 = 115200;
const UART_BAUD_230400: u32 = 230400;
const UART_BAUD_460800: u32 = 460800;
const UART_BAUD_921600: u32 = 921600;

pub struct UART {
    port: *void,
    tx_pin: u32,
    rx_pin: u32,
    baudrate: u32,
    data_bits: u32,
    stop_bits: u32,
    parity: u32,
}

pub struct UARTConfig {
    pub baudrate: u32,
    pub data_bits: u32,
    pub stop_bits: u32,
    pub parity: u32,
    pub flow_control: bool,
    pub translate_crlf: bool,
}

impl UARTConfig {
    // Default configuration: 115200 8N1
    pub fn default() -> UARTConfig {
        UARTConfig {
            baudrate: UART_BAUD_115200,
            data_bits: UART_DATA_BITS_8,
            stop_bits: UART_STOP_BITS_1,
            parity: UART_PARITY_NONE,
            flow_control: false,
            translate_crlf: false,
        }
    }
}

impl UART {
    // Initialize UART with default pins and configuration
    pub fn new_default(port: u8) -> UART {
        Self::new_with_config(port, &UARTConfig::default())
    }
    
    // Initialize UART with default pins and custom baudrate
    pub fn new(port: u8, baudrate: u32) -> UART {
        let mut config = UARTConfig::default();
        config.baudrate = baudrate;
        Self::new_with_config(port, &config)
    }
    
    // Initialize UART with custom pins
    pub fn new_with_pins(port: u8, tx_pin: u32, rx_pin: u32, baudrate: u32) -> UART {
        let uart_base = if port == 0 { UART0_BASE } else { UART1_BASE };
        
        // Initialize UART peripheral
        unsafe {
            let actual_rate = uart_init(uart_base, baudrate);
            
            // Configure GPIO pins for UART function
            gpio_set_function(tx_pin, GPIO_FUNC_UART);
            gpio_set_function(rx_pin, GPIO_FUNC_UART);
            
            // Enable FIFOs
            uart_set_fifo_enabled(uart_base, true);
        }
        
        UART {
            port: uart_base,
            tx_pin,
            rx_pin,
            baudrate,
            data_bits: UART_DATA_BITS_8,
            stop_bits: UART_STOP_BITS_1,
            parity: UART_PARITY_NONE,
        }
    }
    
    // Initialize UART with full configuration
    pub fn new_with_config(port: u8, config: &UARTConfig) -> UART {
        let uart_base = if port == 0 { UART0_BASE } else { UART1_BASE };
        let (tx, rx) = if port == 0 {
            (PICO_DEFAULT_UART_TX_PIN, PICO_DEFAULT_UART_RX_PIN)
        } else {
            (UART1_TX_PIN, UART1_RX_PIN)
        };
        
        // Initialize UART peripheral
        unsafe {
            let actual_rate = uart_init(uart_base, config.baudrate);
            
            // Configure GPIO pins
            gpio_set_function(tx, GPIO_FUNC_UART);
            gpio_set_function(rx, GPIO_FUNC_UART);
            
            // Set data format
            uart_set_format(uart_base, config.data_bits, config.stop_bits, config.parity);
            
            // Enable FIFOs
            uart_set_fifo_enabled(uart_base, true);
            
            // Configure flow control if needed
            if config.flow_control {
                uart_set_hw_flow(uart_base, true, true);
            }
            
            // Configure CRLF translation
            uart_set_translate_crlf(uart_base, config.translate_crlf);
        }
        
        UART {
            port: uart_base,
            tx_pin: tx,
            rx_pin: rx,
            baudrate: config.baudrate,
            data_bits: config.data_bits,
            stop_bits: config.stop_bits,
            parity: config.parity,
        }
    }
    
    // Change UART baudrate
    pub fn set_baudrate(&mut self, baudrate: u32) -> u32 {
        unsafe {
            let actual = uart_set_baudrate(self.port, baudrate);
            self.baudrate = actual;
            actual
        }
    }
    
    // Configure data format
    pub fn set_format(&mut self, data_bits: u32, stop_bits: u32, parity: u32) {
        unsafe {
            uart_set_format(self.port, data_bits, stop_bits, parity);
        }
        self.data_bits = data_bits;
        self.stop_bits = stop_bits;
        self.parity = parity;
    }
    
    // Enable/disable hardware flow control
    pub fn set_flow_control(&self, enable: bool) {
        unsafe {
            uart_set_hw_flow(self.port, enable, enable);
        }
    }
    
    // Check if TX is ready
    pub fn is_writable(&self) -> bool {
        unsafe {
            uart_is_writable(self.port)
        }
    }
    
    // Check if RX has data
    pub fn is_readable(&self) -> bool {
        unsafe {
            uart_is_readable(self.port)
        }
    }
    
    // Write single byte (blocking)
    pub fn write_byte(&self, byte: u8) {
        unsafe {
            uart_putc(self.port, byte);
        }
    }
    
    // Read single byte (blocking)
    pub fn read_byte(&self) -> u8 {
        unsafe {
            uart_getc(self.port)
        }
    }
    
    // Write string (blocking)
    pub fn write_str(&self, s: &str) {
        unsafe {
            uart_write_blocking(
                self.port,
                s.as_ptr() as *const u8,
                s.len() as u32
            );
        }
    }
    
    // Write buffer (blocking)
    pub fn write(&self, data: &[u8]) {
        unsafe {
            uart_write_blocking(
                self.port,
                data.as_ptr() as *const u8,
                data.len() as u32
            );
        }
    }
    
    // Read buffer (blocking)
    pub fn read(&self, buffer: &mut [u8]) {
        unsafe {
            uart_read_blocking(
                self.port,
                buffer.as_mut_ptr() as *u8,
                buffer.len() as u32
            );
        }
    }
    
    // Write formatted string (println-style)
    pub fn println(&self, s: &str) {
        self.write_str(s);
        self.write_byte(b'\r');
        self.write_byte(b'\n');
    }
    
    // Read line until newline (non-blocking, returns bytes read)
    pub fn read_line(&self, buffer: &mut [u8]) -> u32 {
        let mut count: u32 = 0;
        
        while count < buffer.len() as u32 {
            if !self.is_readable() {
                break;
            }
            
            let byte = self.read_byte();
            buffer[count as usize] = byte;
            count += 1;
            
            // Stop at newline
            if byte == b'\n' || byte == b'\r' {
                break;
            }
        }
        
        count
    }
    
    // Available bytes in RX buffer (approximate, checks if readable)
    pub fn available(&self) -> u32 {
        if self.is_readable() { 1 } else { 0 }
    }
    
    // Set break signal
    pub fn set_break(&self, enable: bool) {
        unsafe {
            uart_set_break(self.port, enable);
        }
    }
    
    // Check if UART is enabled
    pub fn is_enabled(&self) -> bool {
        unsafe {
            uart_is_enabled(self.port)
        }
    }
    
    // Get DMA DREQ number for TX
    pub fn get_tx_dreq(&self) -> u32 {
        unsafe {
            uart_get_dreq(self.port, true)
        }
    }
    
    // Get DMA DREQ number for RX
    pub fn get_rx_dreq(&self) -> u32 {
        unsafe {
            uart_get_dreq(self.port, false)
        }
    }
    
    // Deinitialize UART
    pub fn deinit(&self) {
        unsafe {
            uart_deinit(self.port);
        }
    }
}

// Helper function: Initialize UART0 with 115200 baud (USB serial)
pub fn init_uart0_usb() -> UART {
    UART::new_default(0)
}

// Helper function: Initialize UART1 with custom baudrate
pub fn init_uart1(baudrate: u32) -> UART {
    UART::new(1, baudrate)
}

// Example: Serial console output
pub fn example_serial_console() {
    let uart = init_uart0_usb();
    
    uart.println("RP2040 UART Console");
    uart.println("Type something...");
    
    loop {
        if uart.is_readable() {
            let byte = uart.read_byte();
            
            // Echo character
            uart.write_byte(byte);
            
            // Print hex value
            let msg = format!(" (0x{:02X})\r\n", byte);
            uart.write_str(&msg);
            
            if byte == b'q' {
                uart.println("Exiting...");
                break;
            }
        }
    }
}

// Example: GPS module communication (9600 baud)
pub fn example_gps_module() {
    let mut config = UARTConfig::default();
    config.baudrate = UART_BAUD_9600;
    
    let uart = UART::new_with_config(1, &config);
    
    uart.println("Waiting for GPS data...");
    
    let mut buffer: [u8; 128] = [0; 128];
    
    loop {
        let bytes_read = uart.read_line(&mut buffer);
        
        if bytes_read > 0 {
            // Print NMEA sentence
            let sentence = String::from_utf8_lossy(&buffer[0..bytes_read as usize]);
            
            if sentence.starts_with("$GPGGA") {
                uart.print("GPS Fix: ");
                uart.println(&sentence);
            }
        }
    }
}

// Example: AT command modem communication
pub fn example_at_modem() {
    let uart = UART::new(1, UART_BAUD_115200);
    
    // Send AT command
    uart.println("AT");
    
    // Wait for response
    let mut buffer: [u8; 64] = [0; 64];
    let bytes = uart.read_line(&mut buffer);
    
    if bytes > 0 {
        let response = String::from_utf8_lossy(&buffer[0..bytes as usize]);
        
        if response.contains("OK") {
            uart.println("Modem ready!");
            
            // Query signal strength
            uart.println("AT+CSQ");
        }
    }
}

// Example: Binary data transmission
pub fn example_binary_data() {
    let uart = init_uart0_usb();
    
    // Send binary packet
    let packet: [u8; 8] = [
        0xFF, 0xAA,        // Header
        0x04,              // Length
        0x01, 0x02, 0x03,  // Data
        0x06,              // Checksum
        0x55               // Footer
    ];
    
    uart.write(&packet);
    
    // Read response
    let mut response: [u8; 8] = [0; 8];
    uart.read(&mut response);
    
    uart.println("Binary exchange complete");
}

// Example: High-speed data logging (921600 baud)
pub fn example_high_speed_logging() {
    let uart = UART::new(0, UART_BAUD_921600);
    
    uart.println("High-speed logging started");
    
    let mut counter: u32 = 0;
    
    loop {
        let log_msg = format!("[{}] Sensor value: {}\r\n", counter, counter * 123);
        uart.write_str(&log_msg);
        
        counter += 1;
        
        if counter >= 1000 {
            break;
        }
    }
    
    uart.println("Logging complete");
}
