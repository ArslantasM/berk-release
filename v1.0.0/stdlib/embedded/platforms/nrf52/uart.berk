// nRF52 UART Module (UARTE with EasyDMA)
// Hardware Abstraction Layer for nRF52 UART
//
// nRF52 UART Features:
// - 2x UARTE interfaces (UART with EasyDMA)
// - Baudrates: 1200 to 1 Mbaud
// - Hardware flow control (RTS/CTS)
// - EasyDMA for efficient transfers
//
// nRF5 SDK: nrf_drv_uart.h

extern "C" {
    fn nrf_drv_uart_init(instance: *void, config: *void, event_handler: *void) -> u32;
    fn nrf_drv_uart_uninit(instance: *void);
    fn nrf_drv_uart_tx(instance: *void, data: *const u8, len: u8) -> u32;
    fn nrf_drv_uart_rx(instance: *void, data: *u8, len: u8) -> u32;
}

const UART_BAUDRATE_9600: u32 = 9600;
const UART_BAUDRATE_115200: u32 = 115200;
const UART_BAUDRATE_1M: u32 = 1000000;

pub struct UART {
    instance: *void,
    baudrate: u32,
}

impl UART {
    pub fn new(instance: u8, tx: u32, rx: u32, baudrate: u32) -> UART {
        UART { instance: core::ptr::null(), baudrate }
    }
    
    pub fn write(&self, data: &[u8]) -> u32 {
        unsafe {
            nrf_drv_uart_tx(self.instance, data.as_ptr(), data.len() as u8)
        }
    }
    
    pub fn read(&self, buffer: &mut [u8]) -> u32 {
        unsafe {
            nrf_drv_uart_rx(self.instance, buffer.as_mut_ptr(), buffer.len() as u8)
        }
    }
    
    pub fn write_str(&self, s: &str) -> u32 {
        self.write(s.as_bytes())
    }
    
    pub fn println(&self, s: &str) {
        self.write_str(s);
        self.write(b"\r\n");
    }
}
